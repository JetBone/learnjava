package com.jetbone.others.design.patterns.structural.decorator.v2;

/**
 * Created by Chris on 2019/8/26
 */
public class Test {
    public static void main(String[] args) {

        // 这里的batterCake就像是元数据一样，没有它，则后面的装饰者也都没法执行
        // 毕竟没有被装饰者，如何装饰
        // 没有煎饼果子，还加啥蛋和肠啊
        IBatterCake batterCake = new BatterCake();
        batterCake = new EggDecorator(batterCake); // 加一个蛋
        batterCake = new EggDecorator(batterCake); // 再加一个蛋
        batterCake = new SausageDecorator(batterCake); // 再加一根肠
        System.out.println(batterCake.getDesc() + " 价格：" + batterCake.cost());

        // 下面说的接口也可以是抽象类，这里统一按照接口的方式描述
        // 通常呢，实现一个接口，那么我们就会潜意识的想着要实现这个接口的抽象方法
        // 而装饰者虽然实现了一个接口，但是实际上并没有真的去实现接口中的抽象方法
        // 而是内部增加一个父类的参数，然后在继承下来的抽象方法中再调用父类的相同方法
        // 这样绕了一圈后，等于说我虽然实现了这个接口，但是我并没有对继承的抽象方法进行具体实现
        // 那么这样绕了一圈后，实现了接口但实际没有实现抽象方法，装饰者到底干了什么呢
        // 我们可以在装饰者中在调用父类接口前/后增加一些自己想增加的逻辑，而不用去实现父类的抽象方法
        // 这样就相当于完成了动态的增加方法，也就是所谓的"装饰"行为了
        // 当我们真正的想使用这个装饰者的时候，就一定要有一个真正意义中实现了接口的类(抽象方法都进行了真实具体的实现)
        // 这个真正意义中实现了接口的类，就是我们的被装饰者，也就是说，想要用装饰者，就一定要先有被装饰者
        // 装饰者内部的构造器中，必然含有父类参数，这也表明了，如果想创造一个装饰者，就得用被装饰者去构造
        // 最终被构造出来的装饰者实例，到底还可以叫装饰者吗？
        // 最终构造出的装饰者实例，应该叫做"被装饰好的"接口实现类
        // 当你实际调用这个实现类的某个方法的时候，那么调用的是
        // 先调用装饰者内部实现的方法，处理一些被装饰上去的逻辑
        // 处理完之后，再调用最一开始传入的被装饰者实例(真正意义上的实现类)实现的相同接口方法
        // 最终完成了一个"装饰"的概念
    }
}
