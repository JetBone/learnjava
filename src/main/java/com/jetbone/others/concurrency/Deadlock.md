# Deadlock

死锁一般发生在两个或多个线程在获取一些已经被其它线程获取到的锁，这些线程就会被阻塞，但是也不会释放自己已经获取的锁。

死锁一般发生在不同线程获取相同的锁，但是这些锁的获取顺序不相同。

## Deadlock Prevention

### Lock Ordering

如果多个线程获取一系列锁的顺序完全相同，那么是不会发生死锁问题的。

### Lock Timeout

设置获取锁等待的超时时间，如果超过这个时间，则线程放弃获取锁，并且回退数据，释放所有已经获取的锁。

但是如果在拥有大量线程获取相同资源的情况下，可能会导致大量的timeout，甚至有一些线程将一只处于timeout，重试，timeout的状态，永远无法获取到资源。

另外一个问题是 java本身是不能设置进入 synchronized 的timeout时间，如果要实现这个功能功能，需要自定义lock，当然 java 已经提供了 java.util.concurrency 帮我们解决问题。

### Deadlock Detection

Deadlock detection 是一种比较重量级的技术，一般在不能使用 lock ordering 和设置 timeout 的情况下使用。

当一个线程请求获取一个锁，但是这个请求被拒绝的时候，这个线程可以通过 lock graph 去追溯这个锁，检查是否出现死锁。

很多情况下，死锁的发生是非常复杂的，不是简单的两个线程互相死锁，也许涉及到的线程和锁多达实际十几个或者几十个。

一旦死锁被检测到，当前线程会回退数据，并且释放所有已经获取的锁。但是这个操作只会在真的检测到死锁发生才会进行，只是timeout是不会进行这个操作的。同样，多个线程竞争相同资源，也会造成之前提到的，有一些线程将可能永远处于重试，死锁，重试的状态。

最佳的解决方式是设置线程的优先级，这样来确保当资源被释放的时候，优先级高的线程将优先获取资源锁。

